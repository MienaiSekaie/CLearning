11.1 算法的概念

算法（algorithm）是将一组输入转化成一组输出的一系列计算步骤，其中每个步骤必须能在有限时间内完成

算法是用来解决一类计算问题的

11.2 插入排序

证明算法使用数学归纳法
Loop Invariant:
1、第一次执行循环体之前该判断条件为真
2、如果“第N-1次循环之后(或者说第N次循环之前)该判断条件为真”这个条件可以成立，那么就有办法证明第N次循环之后该判断条件仍为真
3、如果在所有循环结束后该判断条件为真，那么就有办法证明该算法正确地解决了问题

习题
实现排序算法，每次找出最小的数交换位置

int i_min(int n)
{
    int i, min = 10000, index;
    for (i = n; i < LEN; i++)
        if (min > a[i]){
            min = a[i];
            index = i;
        }
    return index;
}

void insertion1(void)
{
    int i, index, temp;
    printf("%d, %d, %d, %d, %d\n",
            a[0], a[1], a[2], a[3], a[4]);
    for (i = 0; i < LEN - 1; i++){
        index = i_min(i);
        temp = a[i];
        a[i] = a[index];
        a[index] = temp;
        printf("%d, %d, %d, %d, %d\n",
                a[0], a[1], a[2], a[3], a[4]);
    }
}

11.3 算法的时间复杂度分析

分析算法时间复杂度时，通常关心最坏情况：
1、最坏情况给出了算法执行时间的上界
2、对于某些算法，最坏的情况常有发生，例如查找一个信息在数据库中存在不存在

Θ(g(n))表示和g(n)同一量级的一类函数，例如所有的二次函数f(n)和g(n)=n²属于同一量级，都可以用Θ(n²)表示

常见的时间复杂度函数按量级从小到大的顺序：
Θ(lgn),Θ(sqrt(n)),Θ(n),Θ(nlgn),Θ(n²),Θ(n³),Θ(2ⁿ),Θ(n!)

11.4 归并排序

采取分而治之（Divide-and-Conquer）的策略，时间复杂度是Θ(nlgn)
1、Divide: 把长度为n的输入序列分成两个长度为n/2的子序列
2、Conquer：对这两个子序列分别采用归并排序
3、Combine：将两个排序好的子序列合并成一个最终的排序序列
