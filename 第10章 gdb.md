调试的基本思想：分析现象-->假设错误原因-->产生新的现象去假设验证

10.1 单步执行和跟踪函数调用

gcc -g main.c -o main
编译时加上-g选项，生成的可执行文件能用gdb进行源码级调试

-g的作用是在可执行文件中加入源代码的信息

主要过程：
gcc -g
gdb a.out
list 1从第一行开始列出源代码，一次10行
l add_range 用函数名作参数列出函数源代码
直接输入enter表示执行上一个命令
把源代码改名或挪到别处就不能使用gdb调试，可见gcc的-g选项并不是把源代码嵌入可执行文件中，应该是将源代码和可执行文件对应起来
start开始调试
n 一条一条执行语句
s 也是一条一条执行语句，并且碰到函数则进入函数
bt 查看函数调用的栈帧
i locals 查看函数的局部变量
f 1可以切换栈帧
finish让函数一直运行到当前函数返回为止
set var sum=0

gdb基本命令1
backtrace(或bt)   查看各级函数调用及参数
finish   连续运行到当前函数返回为止，然后停下来等待命令
frame(或f)帧编号   选择栈帧
info(或i) locals   查看当前栈帧局部变量的值
list(或l)   列出源代码，接着上次的位置往下列，每次列10行（可以以行号、函数名为参数）
next(或n)   执行下一条语句
print(或p)   打印表达式的值，通过表达式可以修改变量的值或者调用函数
quit(或q)   退出gdb调试环境
set var   修改变量的值
start 开始执行程序，停在main函数第一行语句前面等待命令
step(或s)   执行下一条语句，如果有函数调用则进入函数中

10.2 断点

gdb基本命令2
break(或b) 行号   在某一行设置断点
break 函数名   在某个函数开头设置断点
break...if...设置条件断点
continue(或c)   从当前位置开始连续运行程序
delete breakpoints 断点号   删除断点
display 变量名   跟踪查看某个变量，每次停下来都显示它的值
disable breakpoints 断点号   禁用断点
enable 断点号   启用断点
info(或i) breakpoints   查看当前设置了哪些断点
run(或r)   从头开始连续运行程序
undisplay 跟踪显示号   取消跟踪显示

10.3 观察点

数组访问越界不会检查

x/7bx input
打印出input存储单元里保存的内容
x命令打印指定存储单元里保存的内容，7bx是打印格式，7表示打印7组，b表示每个字节一组，x表示按十六进制格式打印

watch input[5]
设置观察点观察input数组后面那个字节的数据

gdb基本命令3
watch   设置观察点
info(或i) watchpoints   查看当前设置了哪些观察点
x   从某个位置开始打印存储单元的内容，全部当成字节来看，而不区分哪个字节属于哪个变量

10.4 段错误

段错误就是指访问的内存超出了系统所给这个程序的内存空间
一旦一个程序发生了越界访问，CPU就会产生相应的保护，于是segmentation fault就出现，段错误应该是访问了不可访问的内存，这个内存区要么是不存在的，要么是受到系统保护的，还有可能是缺少文件或者文件损坏

在gdb中运行，遇到段错误会自动停下来，这时可以用命令查看当前执行到哪一行代码了。

如果某个函数的局部变量发生访问越界，有可能并不立即产生段错误，而是在函数返回时产生段错误
